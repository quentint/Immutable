<!DOCTYPE html>
<html>
<head>
    <title>innmind/immutable</title>
    <link rel="stylesheet" href="https://innmind.github.io/Immutable/static/main.css"/>
    <link rel="stylesheet" href="https://innmind.github.io/Immutable/static/styles/default.css"/>
    <link rel="stylesheet" href="https://innmind.github.io/Immutable/static/styles/atom-one-dark.css"/>
    <script src="https://innmind.github.io/Immutable/static/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
    <header>
        <a href="https://innmind.github.io/Immutable/"><code>immutable</code></a>
    </header>
    <aside>
        <ul>
                    <li>
                                    <a href="https://innmind.github.io/Immutable/index.html">
                        Getting started
                    </a>
                            </li>
                    <li>
                                    <details open>
                        <summary>
                                                            Structures
                                                    </summary>
                        <ul>
                                                            <li class="sub-item current">
                                    <a href="https://innmind.github.io/Immutable/SEQUENCE.html">
                                        Sequence
                                    </a>
                                </li>
                                                            <li class="sub-item ">
                                    <a href="https://innmind.github.io/Immutable/SET.html">
                                        Set
                                    </a>
                                </li>
                                                            <li class="sub-item ">
                                    <a href="https://innmind.github.io/Immutable/MAP.html">
                                        Map
                                    </a>
                                </li>
                                                            <li class="sub-item ">
                                    <a href="https://innmind.github.io/Immutable/STR.html">
                                        Str
                                    </a>
                                </li>
                                                            <li class="sub-item ">
                                    <a href="https://innmind.github.io/Immutable/REGEXP.html">
                                        RegExp
                                    </a>
                                </li>
                                                            <li class="sub-item ">
                                    <a href="https://innmind.github.io/Immutable/MAYBE.html">
                                        Maybe
                                    </a>
                                </li>
                                                            <li class="sub-item ">
                                    <a href="https://innmind.github.io/Immutable/EITHER.html">
                                        Either
                                    </a>
                                </li>
                                                            <li class="sub-item ">
                                    <a href="https://innmind.github.io/Immutable/STATE.html">
                                        State
                                    </a>
                                </li>
                                                    </ul>
                    </details>
                            </li>
                    <li>
                                    <details open>
                        <summary>
                                                            Use cases
                                                    </summary>
                        <ul>
                                                            <li class="sub-item ">
                                    <a href="https://innmind.github.io/Immutable/LAZY_FILE.html">
                                        How to read a file
                                    </a>
                                </li>
                                                            <li class="sub-item ">
                                    <a href="https://innmind.github.io/Immutable/PARSING.html">
                                        Parsing strings
                                    </a>
                                </li>
                                                    </ul>
                    </details>
                            </li>
                    <li>
                                    <a href="https://innmind.github.io/Immutable/BLACKBOX.html">
                        Blackbox
                    </a>
                            </li>
                    <li>
                                    <a href="https://innmind.github.io/Immutable/PHILOSOPHY.html">
                        Philosophy
                    </a>
                            </li>
                </ul>
    </aside>
    <main><h1 id="sequence"><a href="#sequence" class="anchor">#</a><code>Sequence</code></h1>
<p>A sequence is an ordered list of elements, think of it like an array such as <code>[1, 'a', new stdClass]</code> or a <code>list<T></code> in the <a href="http://psalm.dev/">Psalm</a> nomenclature.</p>
<h2 id="of"><a href="#of" class="anchor">#</a><code>::of()</code></h2>
<p>The <code>of</code> static method allows you to create a new sequence with all the elements passed as arguments.</p>
<pre><code class="language-php">use Innmind\Immutable\Sequence;

/** @var Sequence<int> */
Sequence::of(1, 2, 3, $etc);</code></pre>
<h2 id="defer"><a href="#defer" class="anchor">#</a><code>::defer()</code></h2>
<p>This named constructor is for advanced use cases where you want the data of your sequence to be loaded upon use only and not initialisation.</p>
<p>An example for such a use case is a sequence of log lines coming from a file:</p>
<pre><code class="language-php">$sequence = Sequence::defer((function() {
    yield from readSomeFile('apache.log');
})());</code></pre>
<p>The method ask a generator that will provide the elements. Once the elements are loaded they are kept in memory so you can run multiple operations on it without loading the file twice.</p>
<p><strong>Important</strong>: beware of the case where the source you read the elements is not altered before the first use of the sequence.</p>
<h2 id="lazy"><a href="#lazy" class="anchor">#</a><code>::lazy()</code></h2>
<p>This is similar to <code>::defer()</code> with the exception that the elements are not kept in memory but reloaded upon each use.</p>
<pre><code class="language-php">$sequence = Sequence::lazy(function() {
    yield from readSomeFile('apache.log');
});</code></pre>
<p><strong>Important</strong>: since the elements are reloaded each time the immutability responsability is up to you because the source may change or if you generate objects it will generate new objects each time (so if you make strict comparison it will fail).</p>
<h2 id="mixed"><a href="#mixed" class="anchor">#</a><code>::mixed()</code></h2>
<p>This is a shortcut for <code>::of(mixed ...$mixed)</code>.</p>
<h2 id="ints"><a href="#ints" class="anchor">#</a><code>::ints()</code></h2>
<p>This is a shortcut for <code>::of(int ...$ints)</code>.</p>
<h2 id="floats"><a href="#floats" class="anchor">#</a><code>::floats()</code></h2>
<p>This is a shortcut for <code>::of(float ...$floats)</code>.</p>
<h2 id="strings"><a href="#strings" class="anchor">#</a><code>::strings()</code></h2>
<p>This is a shortcut for <code>::of(string ...$strings)</code>.</p>
<h2 id="objects"><a href="#objects" class="anchor">#</a><code>::objects()</code></h2>
<p>This is a shortcut for <code>::of(object ...$objects)</code>.</p>
<h2 id="invoke"><a href="#invoke" class="anchor">#</a><code>->__invoke()</code></h2>
<p>Augment the sequence with a new element.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1);
$sequence = ($sequence)(2);
$sequence->equals(Sequence::ints(1, 2));</code></pre>
<h2 id="add"><a href="#add" class="anchor">#</a><code>->add()</code></h2>
<p>This is an alias for <code>->__invoke()</code>.</p>
<h2 id="size"><a href="#size" class="anchor">#</a><code>->size()</code></h2>
<p>This returns the number of elements in the sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 4, 6);
$sequence->size(); // 3</code></pre>
<h2 id="count"><a href="#count" class="anchor">#</a><code>->count()</code></h2>
<p>This is an alias for <code>->size()</code>, but you can also use the PHP function <code>\count</code> if you prefer.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 4, 6);
$sequence->count(); // 3
\count($sequence); // 3</code></pre>
<h2 id="get"><a href="#get" class="anchor">#</a><code>->get()</code></h2>
<p>This method will return a <a href="maybe.html"><code>Maybe</code></a> object containing the element at the given index in the sequence. If the index doesn't exist it will an empty <code>Maybe</code> object.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 4, 6);
$sequence->get(1); // Maybe::just(4)
$sequence->get(3); // Maybe::nothing()</code></pre>
<h2 id="diff"><a href="#diff" class="anchor">#</a><code>->diff()</code></h2>
<p>This method will return a new sequence containing the elements that are not present in the other sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 4, 6)->diff(Sequence::ints(1, 3, 6));
$sequence->equals(Sequence::ints(4)); // true</code></pre>
<h2 id="distinct"><a href="#distinct" class="anchor">#</a><code>->distinct()</code></h2>
<p>This removes any duplicates in the sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 1, 3)->distinct();
$sequence->equals(Sequence::ints(1, 2, 3)); // true</code></pre>
<h2 id="drop"><a href="#drop" class="anchor">#</a><code>->drop()</code></h2>
<p>This removes the number of elements from the end of the sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(5, 4, 3, 2, 1)->drop(2);
$sequence->equals(Sequence::ints(3, 2, 1)); // true</code></pre>
<h2 id="dropend"><a href="#dropend" class="anchor">#</a><code>->dropEnd()</code></h2>
<p>This removes the number of elements from the end of the sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 3, 4, 5)->drop(2);
$sequence->equals(Sequence::ints(1, 2, 3)); // true</code></pre>
<h2 id="equals"><a href="#equals" class="anchor">#</a><code>->equals()</code></h2>
<p>Check if two sequences are identical.</p>
<pre><code class="language-php">Sequence::ints(1, 2)->equals(Sequence::ints(1, 2)); // true
Sequence::ints()->equals(Sequence::strings()); // false but psalm will raise an error</code></pre>
<h2 id="filter"><a href="#filter" class="anchor">#</a><code>->filter()</code></h2>
<p>Removes elements from the sequence that don't match the given predicate.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 3, 4)->filter(fn($i) => $i % 2 === 0);
$sequence->equals(Sequence::ints(2, 4));</code></pre>
<h2 id="foreach"><a href="#foreach" class="anchor">#</a><code>->foreach()</code></h2>
<p>Use this method to call a function for each element of the sequence. Since this structure is immutable it returns a <code>SideEffect</code> object, as its name suggest it is the only place acceptable to create side effects.</p>
<pre><code class="language-php">$sideEffect = Sequence::strings('hello', 'world')->foreach(function(string $string): void {
    echo $string.' ';
});</code></pre>
<p>In itself the <code>SideEffect</code> object has no use except to avoid psalm complaining that the <code>foreach</code> method is not used.</p>
<h2 id="groupby"><a href="#groupby" class="anchor">#</a><code>->groupBy()</code></h2>
<p>This will create multiples sequences with elements regrouped under the same key computed by the given function.</p>
<pre><code class="language-php">$urls = Sequence::strings(
    'http://example.com',
    'http://example.com/foo',
    'https://example.com',
    'ftp://example.com',
);
/** @var Innmind\Immutable\Map<string, Sequence<string>> */
$map = $urls->groupBy(fn(string $url): string => \parse_url($url)['scheme']);
$map
    ->get('http')
    ->match(
        static fn($group) => $group,
        static fn() => Sequence::strings(),
    )
    ->equals(Sequence::strings('http://example.com', 'http://example.com/foo')); // true
$map
    ->get('https')
    ->match(
        static fn($group) => $group,
        static fn() => Sequence::strings(),
    )
    ->equals(Sequence::strings('https://example.com')); // true
$map
    ->get('ftp')
    ->match(
        static fn($group) => $group,
        static fn() => Sequence::strings(),
    )
    ->equals(Sequence::strings('ftp://example.com')); // true</code></pre>
<h2 id="first"><a href="#first" class="anchor">#</a><code>->first()</code></h2>
<p>This is an alias for <code>->get(0)</code>.</p>
<h2 id="last"><a href="#last" class="anchor">#</a><code>->last()</code></h2>
<p>This is an alias for <code>->get(->size() - 1)</code>.</p>
<h2 id="contains"><a href="#contains" class="anchor">#</a><code>->contains()</code></h2>
<p>Check if the element is present in the sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 42, 3);
$sequence->contains(2); // false
$sequence->contains(42); // true
$sequence->contains('42'); // false but psalm will raise an error</code></pre>
<h2 id="indexof"><a href="#indexof" class="anchor">#</a><code>->indexOf()</code></h2>
<p>This will return a <a href="maybe.html"><code>Maybe</code></a> object containing the index number at which the first occurence of the element was found.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 3, 2);
$sequence->indexOf(2); // Maybe::just(1)
$sequence->indexOf(4); // Maybe::nothing()</code></pre>
<h2 id="indices"><a href="#indices" class="anchor">#</a><code>->indices()</code></h2>
<p>Create a new sequence of integers representing the indices of the original sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 3);
$sequence->indices()->equals(Sequence::ints(...\range(0, $sequence->size() - 1)));</code></pre>
<h2 id="map"><a href="#map" class="anchor">#</a><code>->map()</code></h2>
<p>Create a new sequence with the exact same number of elements but modified by the given function.</p>
<pre><code class="language-php">$ints = Sequence::ints(1, 2, 3);
$squares = $ints->map(fn($i) => $i**2);
$squares->equals(Sequence::ints(1, 4, 9)); // true</code></pre>
<h2 id="flatmap"><a href="#flatmap" class="anchor">#</a><code>->flatMap()</code></h2>
<p>This is similar to <code>->map()</code> except that instead of returning a new value it returns a new sequence for each value, and each new sequence is appended together.</p>
<pre><code class="language-php">$ints = Sequence::ints(1, 2, 3);
$squares = $ints->flatMap(fn($i) => Sequence::of($i, $i**2));
$squares->equals(Sequence::ints(1, 1, 2, 4, 3, 9)); // true</code></pre>
<h2 id="pad"><a href="#pad" class="anchor">#</a><code>->pad()</code></h2>
<p>Add the same element to a new sequence in order that its size is at least the given one.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 3);
$sequence->pad(2, 0)->equals(Sequence::ints(1, 2, 3)); // true
$sequence->pad(5, 0)->equals(Sequence::ints(1, 2, 3, 0, 0)); // true</code></pre>
<h2 id="partition"><a href="#partition" class="anchor">#</a><code>->partition()</code></h2>
<p>This method is similar to <code>->groupBy()</code> method but the map keys are always booleans. The difference is that here the 2 keys are always present whereas with <code>->groupBy()</code> it will depend on the original sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 3);
/** @var Map<bool, Sequence<int>> */
$map = $sequence->partition(fn($int) => $int % 2 === 0);
$map
    ->get(true)
    ->match(
        static fn($partition) => $partition,
        static fn() => Sequence::ints(),
    )
    ->equals(Sequence::ints(2)); // true
$map
    ->get(false)
    ->match(
        static fn($partition) => $partition,
        static fn() => Sequence::ints(),
    )
    ->equals(Sequence::ints(1, 3)); // true</code></pre>
<h2 id="slice"><a href="#slice" class="anchor">#</a><code>->slice()</code></h2>
<p>Return a new sequence with only the elements that were between the given indices. (The upper bound is not included)</p>
<pre><code class="language-php">$sequence = Sequence::ints(4, 3, 2, 1);
$sequence->slice(1, 4)->equals(Sequence::ints(3, 2)); // true</code></pre>
<h2 id="take"><a href="#take" class="anchor">#</a><code>->take()</code></h2>
<p>Create a new sequence with only the given number of elements from the start of the sequence.</p>
<pre><code class="language-php">Sequence::ints(4, 3, 1, 0)->take(2)->equals(Sequence::ints(4, 3)); // true</code></pre>
<h2 id="takeend"><a href="#takeend" class="anchor">#</a><code>->takeEnd()</code></h2>
<p>Similar to <code>->take()</code> but it starts from the end of the sequence</p>
<pre><code class="language-php">Sequence::ints(4, 3, 1, 0)->takeEnd(2)->equals(Sequence::ints(1, 0)); // true</code></pre>
<h2 id="append"><a href="#append" class="anchor">#</a><code>->append()</code></h2>
<p>Add all elements of a sequence at the end of another.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2)->append(Sequence::ints(3, 4));
$sequence->equals(Sequence::ints(1, 2, 3, 4)); // true</code></pre>
<h2 id="intersect"><a href="#intersect" class="anchor">#</a><code>->intersect()</code></h2>
<p>Create a new sequence with the elements that are also in the other sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 3)->intersect(Sequence::ints(2, 3, 4));
$sequence->equals(Sequence::ints(2, 3)); // true</code></pre>
<h2 id="sort"><a href="#sort" class="anchor">#</a><code>->sort()</code></h2>
<p>Reorder the elements within the sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(4, 2, 3, 1);
$sequence = $sequence->sort(fn($a, $b) => $a <=> $b);
$sequence->equals(Sequence::ints(1, 2, 3, 4));</code></pre>
<h2 id="reduce"><a href="#reduce" class="anchor">#</a><code>->reduce()</code></h2>
<p>Iteratively compute a value for all the elements in the sequence.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 3, 4);
$sum = $sequence->reduce(0, fn($sum, $int) => $sum + $int);
$sum; // 10</code></pre>
<h2 id="clear"><a href="#clear" class="anchor">#</a><code>->clear()</code></h2>
<p>Create an empty new sequence of the same type. (To avoid to redeclare the types manually in a docblock)</p>
<pre><code class="language-php">$sequence = Sequence::ints(1);
$sequence->clear()->size(); // 0</code></pre>
<h2 id="reverse"><a href="#reverse" class="anchor">#</a><code>->reverse()</code></h2>
<p>Create a new sequence where the last element become the first one and so on.</p>
<pre><code class="language-php">$sequence = Sequence::ints(1, 2, 3, 4);
$sequence->reverse()->equals(Sequence::ints(4, 3, 2, 1));</code></pre>
<h2 id="empty"><a href="#empty" class="anchor">#</a><code>->empty()</code></h2>
<p>Tells whether there is at least one element or not.</p>
<pre><code class="language-php">Sequence::ints()->empty(); // true
Sequence::ints(1)->empty(); // false</code></pre>
<h2 id="tolist"><a href="#tolist" class="anchor">#</a><code>->toList()</code></h2>
<p>It returns a new <code>array</code> containing all the elements of the sequence.</p>
<h2 id="find"><a href="#find" class="anchor">#</a><code>->find()</code></h2>
<p>Returns a <a href="maybe.html"><code>Maybe</code></a> object containing the first element that matches the predicate.</p>
<pre><code class="language-php">$sequence = Sequence::ints(2, 4, 6, 8, 9, 10, 11);
$firstOdd = $sequence->find(fn($i) => $i % 2 === 1);
$firstOdd; // Maybe::just(9)
$sequence->find(static fn() => false); // Maybe::nothing()</code></pre>
<h2 id="matches"><a href="#matches" class="anchor">#</a><code>->matches()</code></h2>
<p>Check if all the elements of the sequence matches the given predicate.</p>
<pre><code class="language-php">$isOdd = fn($i) => $i % 2 === 1;
Sequence::ints(1, 3, 5, 7)->matches($isOdd); // true
Sequence::ints(1, 3, 4, 5, 7)->matches($isOdd); // false</code></pre>
<h2 id="any"><a href="#any" class="anchor">#</a><code>->any()</code></h2>
<p>Check if at least one element of the sequence matches the given predicate.</p>
<pre><code class="language-php">$isOdd = fn($i) => $i % 2 === 1;
Sequence::ints(1, 3, 5, 7)->any($isOdd); // true
Sequence::ints(1, 3, 4, 5, 7)->any($isOdd); // true
Sequence::ints(2, 4, 6, 8)->any($isOdd); // false</code></pre>
<h2 id="match"><a href="#match" class="anchor">#</a><code>->match()</code></h2>
<p>This is a similar approach to pattern matching allowing you to decompose a sequence by accessing the first element and the rest of the sequence.</p>
<pre><code class="language-php">function sum(Sequence $ints): int
{
    return $ints->match(
        fn(int $head, Sequence $tail) => $head + sum($tail),
        fn() => 0,
    );
}

$result = sum(Sequence::of(1, 2, 3, 4));
$result; // 10</code></pre>
<p><strong>Important</strong>: for lasy sequences bear in mind that the values will be kept in memory while the first call to <code>->match</code> didn't return.</p></main>
    <footer>
        <a href="https://github.com/innmind/Immutable/" target="_blank">GitHub</a>
    </footer>
</body>
</html>